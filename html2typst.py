"""
Production-quality HTML to Typst translator.
Designed for HTML generated by Quill.js editor.
"""

import re
import logging
from html.parser import HTMLParser
from typing import Optional, List, Dict, Any
from io import StringIO


class RenderContext:
    """Context for tracking state during HTML rendering."""
    
    def __init__(self, debug: bool = False, debug_log_path: Optional[str] = None):
        self.debug = debug
        self.debug_log_path = debug_log_path
        self.logger = None
        self.style_stack = []  # Track open styles for safe delimiter management
        self.list_stack = []  # Track nested lists
        self.in_list_item = False
        
        if debug and debug_log_path:
            self._setup_logger()
    
    def _setup_logger(self):
        """Setup file logger for debug mode."""
        self.logger = logging.getLogger('html2typst')
        self.logger.setLevel(logging.DEBUG)
        
        # Clear any existing handlers
        self.logger.handlers.clear()
        
        # File handler
        fh = logging.FileHandler(self.debug_log_path, mode='w', encoding='utf-8')
        fh.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        fh.setFormatter(formatter)
        self.logger.addHandler(fh)
    
    def log(self, message: str, level: str = 'info'):
        """Log message if in debug mode."""
        if self.logger:
            if level == 'debug':
                self.logger.debug(message)
            elif level == 'warning':
                self.logger.warning(message)
            elif level == 'error':
                self.logger.error(message)
            else:
                self.logger.info(message)


class QuillStyleParser:
    """Parser for Quill.js specific styles and classes."""
    
    @staticmethod
    def parse_quill_classes(class_str: str, context: RenderContext) -> Dict[str, Any]:
        """Parse Quill CSS classes and extract styling information."""
        result = {
            'indent': None,
            'align': None,
            'size': None,
            'font': None,
        }
        
        if not class_str:
            return result
        
        classes = class_str.split()
        
        for cls in classes:
            # Handle indent: ql-indent-1, ql-indent-2, etc.
            if cls.startswith('ql-indent-'):
                indent_str = cls.replace('ql-indent-', '')
                if indent_str and indent_str.isdigit():
                    try:
                        indent_level = int(indent_str)
                        result['indent'] = indent_level
                        context.log(f"Parsed indent class: {cls} -> level {indent_level}", 'debug')
                    except ValueError:
                        context.log(f"Invalid indent class: {cls}", 'warning')
                else:
                    context.log(f"Invalid indent class format: {cls}", 'warning')
            
            # Handle alignment: ql-align-center, ql-align-right, ql-align-justify
            elif cls.startswith('ql-align-'):
                align = cls.replace('ql-align-', '')
                result['align'] = align
                context.log(f"Parsed align class: {cls} -> {align}", 'debug')
            
            # Handle size: ql-size-small, ql-size-large, ql-size-huge
            elif cls.startswith('ql-size-'):
                size = cls.replace('ql-size-', '')
                result['size'] = size
                context.log(f"Parsed size class: {cls} -> {size}", 'debug')
            
            # Handle font: ql-font-serif, ql-font-monospace
            elif cls.startswith('ql-font-'):
                font = cls.replace('ql-font-', '')
                result['font'] = font
                context.log(f"Parsed font class: {cls} -> {font}", 'debug')
        
        return result
    
    @staticmethod
    def parse_inline_styles(style_str: str, context: RenderContext) -> Dict[str, str]:
        """Parse inline CSS styles."""
        result = {}
        
        if not style_str:
            return result
        
        # Split by semicolon and parse each style
        styles = [s.strip() for s in style_str.split(';') if s.strip()]
        
        for style in styles:
            if ':' in style:
                key, value = style.split(':', 1)
                key = key.strip().lower()
                value = value.strip()
                result[key] = value
                context.log(f"Parsed inline style: {key} = {value}", 'debug')
        
        return result


class HTMLNode:
    """Represents a parsed HTML node."""
    
    def __init__(self, tag: str, attrs: Dict[str, str], parent: Optional['HTMLNode'] = None):
        self.tag = tag
        self.attrs = attrs
        self.children = []
        self.parent = parent
    
    def add_child(self, child: 'HTMLNode'):
        """Add a child node."""
        self.children.append(child)
        child.parent = self


class TextNode:
    """Represents a text node."""
    
    def __init__(self, text: str, parent: Optional[HTMLNode] = None):
        self.text = text
        self.parent = parent


class SimpleHTMLParser(HTMLParser):
    """Simple HTML parser that builds a DOM tree."""
    
    # Self-closing tags that should not have children
    VOID_TAGS = {'br', 'hr', 'img', 'input', 'meta', 'link', 'area', 'base', 'col', 'embed', 'param', 'source', 'track', 'wbr'}
    
    def __init__(self):
        super().__init__()
        self.root = HTMLNode('root', {})
        self.current = self.root
        self.stack = [self.root]
    
    def handle_starttag(self, tag, attrs):
        """Handle opening tag."""
        attrs_dict = dict(attrs)
        node = HTMLNode(tag, attrs_dict, self.current)
        self.current.add_child(node)
        
        # Don't descend into void tags
        if tag.lower() not in self.VOID_TAGS:
            self.current = node
            self.stack.append(node)
    
    def handle_endtag(self, tag):
        """Handle closing tag."""
        if len(self.stack) > 1:
            self.stack.pop()
            self.current = self.stack[-1]
    
    def handle_data(self, data):
        """Handle text data."""
        if data:
            text_node = TextNode(data, self.current)
            self.current.add_child(text_node)
    
    def handle_startendtag(self, tag, attrs):
        """Handle self-closing tags like <br />."""
        attrs_dict = dict(attrs)
        node = HTMLNode(tag, attrs_dict, self.current)
        self.current.add_child(node)


class TypstRenderer:
    """Renders HTML nodes to Typst format."""
    
    def __init__(self, context: RenderContext):
        self.context = context
    
    def render(self, node) -> str:
        """Main render method."""
        if isinstance(node, TextNode):
            return self.render_text(node)
        elif isinstance(node, HTMLNode):
            return self.render_node(node)
        return ''
    
    def render_text(self, node: TextNode) -> str:
        """Render text node with proper escaping for Typst."""
        text = node.text
        
        # Escape special Typst characters
        # We need to be careful with *, _, `, #, @, etc.
        # For now, basic escaping - text content should generally be safe
        # unless it contains Typst special sequences
        
        return text
    
    def render_node(self, node: HTMLNode) -> str:
        """Render HTML node to Typst."""
        tag = node.tag.lower()
        
        self.context.log(f"Rendering node: <{tag}>", 'debug')
        
        # Get attributes
        class_attr = node.attrs.get('class', '')
        style_attr = node.attrs.get('style', '')
        
        # Parse Quill styles
        quill_styles = QuillStyleParser.parse_quill_classes(class_attr, self.context)
        inline_styles = QuillStyleParser.parse_inline_styles(style_attr, self.context)
        
        # Route to appropriate handler
        handler_map = {
            'root': self.render_root,
            'p': self.render_paragraph,
            'div': self.render_div,
            'br': self.render_br,
            'strong': self.render_strong,
            'b': self.render_strong,
            'em': self.render_em,
            'i': self.render_em,
            'u': self.render_underline,
            'ul': self.render_ul,
            'ol': self.render_ol,
            'li': self.render_li,
            'blockquote': self.render_blockquote,
            'pre': self.render_pre,
            'code': self.render_code,
            'a': self.render_link,
            'img': self.render_img,
            'h1': self.render_heading,
            'h2': self.render_heading,
            'h3': self.render_heading,
            'h4': self.render_heading,
            'h5': self.render_heading,
            'h6': self.render_heading,
            'span': self.render_span,
            's': self.render_strikethrough,
            'strike': self.render_strikethrough,
            'del': self.render_strikethrough,
        }
        
        handler = handler_map.get(tag, self.render_generic)
        return handler(node, quill_styles, inline_styles)
    
    def render_children(self, node: HTMLNode) -> str:
        """Render all children of a node."""
        result = []
        for child in node.children:
            result.append(self.render(child))
        return ''.join(result)
    
    def render_root(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render root node."""
        return self.render_children(node)
    
    def render_paragraph(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render paragraph."""
        content = self.render_children(node)
        
        # Handle alignment from Quill
        align = quill_styles.get('align') or inline_styles.get('text-align')
        
        if align == 'center':
            self.context.log(f"Applying center alignment to paragraph", 'debug')
            return f"#align(center)[{content}]\n\n"
        elif align == 'right':
            self.context.log(f"Applying right alignment to paragraph", 'debug')
            return f"#align(right)[{content}]\n\n"
        elif align == 'justify':
            self.context.log(f"Ignoring justify alignment (not mapping to Typst)", 'debug')
            # Typst has justify as default for many contexts, or we skip it
            return f"{content}\n\n"
        else:
            return f"{content}\n\n"
    
    def render_div(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render div as paragraph."""
        return self.render_paragraph(node, quill_styles, inline_styles)
    
    def render_br(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render line break."""
        return "\\\n"
    
    def render_strong(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render bold text."""
        content = self.render_children(node)
        if not content:
            return ''
        return f"*{content}*"
    
    def render_em(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render italic text."""
        content = self.render_children(node)
        if not content:
            return ''
        return f"_{content}_"
    
    def render_underline(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render underlined text."""
        content = self.render_children(node)
        if not content:
            return ''
        # Typst uses #underline() function
        return f"#underline[{content}]"
    
    def render_strikethrough(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render strikethrough text."""
        content = self.render_children(node)
        if not content:
            return ''
        # Typst uses #strike() function
        return f"#strike[{content}]"
    
    def render_ul(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render unordered list."""
        self.context.list_stack.append('ul')
        content = self.render_children(node)
        self.context.list_stack.pop()
        return f"{content}\n"
    
    def render_ol(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render ordered list."""
        self.context.list_stack.append('ol')
        content = self.render_children(node)
        self.context.list_stack.pop()
        return f"{content}\n"
    
    def render_li(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render list item."""
        content = self.render_children(node).strip()  # Strip whitespace
        
        # Determine list type
        list_type = self.context.list_stack[-1] if self.context.list_stack else 'ul'
        
        # Handle indentation from Quill
        indent_level = quill_styles.get('indent', 0)
        
        if indent_level and indent_level > 0:
            self.context.log(f"List item with indent level {indent_level}", 'debug')
            # For now, we'll ignore indent and just render as regular list item
            # In a more sophisticated implementation, we could nest lists
            self.context.log(f"Ignoring indent level (not fully supported), rendering as regular list item", 'debug')
        
        # Handle alignment - for list items, we mostly ignore it but preserve content
        align = quill_styles.get('align') or inline_styles.get('text-align')
        if align:
            self.context.log(f"List item has alignment: {align} (preserving content, ignoring alignment)", 'debug')
        
        if list_type == 'ol':
            return f"+ {content}\n"
        else:
            return f"- {content}\n"
    
    def render_blockquote(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render blockquote."""
        content = self.render_children(node)
        # In Typst, quotes can be done with various methods
        # Using a simple indented style
        lines = content.strip().split('\n')
        quoted = '\n'.join(f"> {line}" if line else ">" for line in lines)
        return f"{quoted}\n\n"
    
    def render_pre(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render preformatted text."""
        # Check if it contains a <code> tag
        has_code = any(isinstance(child, HTMLNode) and child.tag == 'code' for child in node.children)
        
        if has_code:
            # Let the code tag handle it
            return self.render_children(node)
        else:
            # Render as raw/monospace block
            content = self.render_children(node)
            return f"```\n{content}\n```\n\n"
    
    def render_code(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render code."""
        content = self.render_children(node)
        
        # Check if parent is <pre> - then it's a code block
        if node.parent and node.parent.tag == 'pre':
            return f"```\n{content}\n```\n\n"
        else:
            # Inline code
            return f"`{content}`"
    
    def render_link(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render link."""
        content = self.render_children(node)
        href = node.attrs.get('href', '')
        
        if href:
            # Typst link syntax: #link("url")[text]
            return f'#link("{href}")[{content}]'
        else:
            # No href, just render text
            self.context.log(f"Link without href, rendering as plain text", 'debug')
            return content
    
    def render_img(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render image."""
        alt = node.attrs.get('alt', '')
        src = node.attrs.get('src', '')
        
        self.context.log(f"Image encountered: src={src}, alt={alt}", 'debug')
        
        # For HTML to Typst, we can't easily embed images without file paths
        # Fallback: use alt text or empty
        if alt:
            return f"[Image: {alt}]"
        else:
            return ""
    
    def render_heading(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render heading."""
        content = self.render_children(node)
        
        # Validate tag format and extract level
        tag = node.tag.lower()
        if len(tag) == 2 and tag[0] == 'h' and tag[1].isdigit():
            level = int(tag[1])
            level = max(1, min(level, 6))  # Clamp to 1-6
        else:
            # Fallback for unexpected format
            self.context.log(f"Unexpected heading tag format: {tag}, using h1", 'warning')
            level = 1
        
        # Typst headings use = for h1, == for h2, etc.
        heading_marker = '=' * level
        return f"{heading_marker} {content}\n\n"
    
    def render_span(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Render span - usually for inline styling."""
        content = self.render_children(node)
        
        # Check for color styling
        color = inline_styles.get('color', '')
        
        if color:
            # Some colors like "windowtext" are system colors, we ignore them
            if color.lower() in ['windowtext', 'inherit', 'initial']:
                self.context.log(f"Ignoring system color: {color}", 'debug')
                return content
            
            # For actual colors, we could use Typst's #text(fill: color)[content]
            # But for simplicity and safety, we'll ignore color styling
            self.context.log(f"Ignoring color styling: {color} (not mapped)", 'debug')
        
        # Background color
        bg_color = inline_styles.get('background-color', '')
        if bg_color:
            self.context.log(f"Ignoring background-color: {bg_color} (not mapped)", 'debug')
        
        # Font size
        font_size = inline_styles.get('font-size', '')
        if font_size:
            self.context.log(f"Ignoring font-size: {font_size} (not mapped)", 'debug')
        
        # For spans, we just render the content
        return content
    
    def render_generic(self, node: HTMLNode, quill_styles: Dict, inline_styles: Dict) -> str:
        """Fallback renderer for unknown tags."""
        self.context.log(f"Unknown tag <{node.tag}>, degrading to plain text", 'warning')
        return self.render_children(node)


def translate_html_to_typst(
    html: str,
    debug: bool = False,
    debug_log_path: Optional[str] = None
) -> str:
    """
    Translate HTML (generated by Quill.js) to Typst code.
    
    Args:
        html: HTML string to convert
        debug: Enable debug mode
        debug_log_path: Path to debug log file (required if debug=True)
    
    Returns:
        Typst formatted string
    
    Modes:
        PRODUCTION (debug=False):
            - Generates clean, safe Typst
            - No comments, markers, warnings in output
            - No logs
            - 100% of text content MUST appear
        
        DEBUG (debug=True):
            - Output Typst MUST STILL BE CLEAN (like production)
            - ALL diagnostic info written ONLY to log file
            - Must not add any debug info to Typst output
            - debug_log_path specifies the log file
    
    Principles:
        - text > style
        - structure > style
        - No text can be omitted
        - Every HTML node is either mapped or degraded to plain text
    """
    # Create rendering context
    context = RenderContext(debug=debug, debug_log_path=debug_log_path)
    
    if debug:
        context.log("=== HTML to Typst Translation Started ===", 'info')
        context.log(f"Input HTML length: {len(html)} characters", 'info')
    
    # Parse HTML
    parser = SimpleHTMLParser()
    
    try:
        parser.feed(html)
    except Exception as e:
        if debug:
            context.log(f"HTML parsing error: {str(e)}", 'error')
        # Even on error, try to continue with whatever was parsed
    
    # Render to Typst
    renderer = TypstRenderer(context)
    
    try:
        typst_output = renderer.render(parser.root)
    except Exception as e:
        if debug:
            context.log(f"Rendering error: {str(e)}", 'error')
        typst_output = ""
    
    # Clean up output
    # Remove excessive blank lines
    typst_output = re.sub(r'\n{3,}', '\n\n', typst_output)
    typst_output = typst_output.strip()
    
    if debug:
        context.log(f"Output Typst length: {len(typst_output)} characters", 'info')
        context.log("=== HTML to Typst Translation Completed ===", 'info')
    
    return typst_output
